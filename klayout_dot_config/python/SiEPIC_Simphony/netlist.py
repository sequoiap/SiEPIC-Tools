import pya
# import jsons

import simphony.core as core
from simphony.DeviceLibrary import ebeam as devices
import SiEPIC_Simphony
# import simphony.errors as err

def spice_netlist_export(self) -> (str, str, core.Netlist):
    """
    This function gathers information from the current top cell in Klayout into
    a netlist for a photonic circuit. This netlist is used in simulations.

    Code for this function is taken and adapted from a function in 
    'SiEPIC-Tools/klayout_dot_config/python/SiEPIC/extend.py' 
    which does the same thing, but to create a netlist for 
    Lumerical INTERCONNECT. This function has parts of that one removed 
    since they are not needed for this toolbox.
    """

    import SiEPIC
    from SiEPIC import _globals
    from time import strftime
    from SiEPIC.utils import eng_str

    from SiEPIC.utils import get_technology
    TECHNOLOGY = get_technology()
    if not TECHNOLOGY['technology_name']:
        v = pya.MessageBox.warning("Errors", "SiEPIC-Tools requires a technology to be chosen.  \n\nThe active technology is displayed on the bottom-left of the KLayout window, next to the T. \n\nChange the technology using KLayout File | Layout Properties, then choose Technology and find the correct one (e.g., EBeam, GSiP).", pya.MessageBox.Ok)
        return 'x', 'x', 0, [0]
    # get the netlist from the entire layout
    nets, components = self.identify_nets()

    if not components:
        v = pya.MessageBox.warning("Errors", "No components found.", pya.MessageBox.Ok)
        return 'no', 'components', 0, ['found']

    text_subckt = '* Spice output from KLayout SiEPIC-Tools v%s, %s.\n\n' % (
        SiEPIC.__version__, strftime("%Y-%m-%d %H:%M:%S"))
        
    circuit_name = self.name.replace('.', '')  # remove "."
    if '_' in circuit_name[0]:
        circuit_name = ''.join(circuit_name.split('_', 1))  # remove leading _

    ioports = -1
    for c in components:
        # optical nets: must be ordered electrical, optical IO, then optical
        nets_str = ''
        for p in c.pins:
            if p.type == _globals.PIN_TYPES.ELECTRICAL:
                nets_str += " " + c.component + '_' + str(c.idx) + '_' + p.pin_name
        for p in c.pins:
            if p.type == _globals.PIN_TYPES.OPTICALIO:
                nets_str += " N$" + str(ioports)
                ioports -= 1
        #pinIOtype = any([p for p in c.pins if p.type == _globals.PIN_TYPES.OPTICALIO])
        for p in c.pins:
            if p.type == _globals.PIN_TYPES.OPTICAL:
                if p.net.idx != None:
                    nets_str += " N$" + str(p.net.idx)
                #if p.net.idx != None:
                #    nets_str += " N$" + str(p.net.idx)
                else:
                    nets_str += " N$" + str(ioports)
                    ioports -= 1

        # Check to see if this component is an Optical IO type.
        pinIOtype = any([p for p in c.pins if p.type == _globals.PIN_TYPES.OPTICALIO])

        component1 = c.component
        params1 = c.params

        text_subckt += ' %s %s %s ' % (component1.replace(' ', '_') +
                                       "_" + str(c.idx), nets_str, component1.replace(' ', '_'))
        x, y = c.Dcenter.x, c.Dcenter.y
        text_subckt += '%s lay_x=%s lay_y=%s\n' % \
            (params1, eng_str(x * 1e-6), eng_str(y * 1e-6))

    om = NetlistParser()
    om_components = om.parse_text(text_subckt)
    nl = core.Netlist()
    nl.components = om_components

    return text_subckt, "output", nl, om.external_list

pya.Cell.spice_netlist_export_ann = spice_netlist_export


class NetlistParser:
    """
    The Parser class reads a netlist generated by the SiEPIC toolbox and uses 
    various classes which inherit from 'models.components.ComponentModel' to create 
    an object based model of a photonic circuit. 
    
    Each derived class is connected to a component model in 'models' that 
    exposes a 'get_s_params' method with its appropriate arguments to the 
    derived model. These s_params are the s-matrices of the component, which 
    are then used to simulate the circuit's transmission behavior.

    Attributes
    ----------
    component_list : list
        A list of objects derived from 'models.components.ComponentModel' 
        representing the photonic circuit.
    net_count : int
        A counter keeping track of the total number of nets in the circuit 
        (0-indexed).
    """

    def __init__(self):
        self.component_list = []
        self.external_list = []

    def parse_file(self, filepath: str) -> list:
        """Converts a netlist to an object model of the circuit.

        Parses through the netlist (given a filename) to identify components 
        and organize them into objects. Objects are connected with their data 
        models, allowing them to retrieve any available parameters.

        Parameters
        ----------
        filepath : str
            The name of the file to be parsed.

        Returns
        -------
        component_list : list
            A list of all components found in the netlist, with their 
            accompanying properties and values.
        """
        with open(filepath) as fid:
            text = fid.read()
            return self.parse_text(text)

    def parse_text(self, text: str) -> list:
        """
        Parses the string format of the netlist. Instead of requiring a file, 
        string representations of netlists can also be converted into an object
        model.

        Parameters
        ----------
        text : str
            The text of the netlist.
        
        Returns
        -------
        component_list : list
            A list of all components found in the netlist, with their 
            accompanying properties and values.
        """
        lines = text.splitlines()
        for line in lines:
                elements = line.split()
                if len(elements) > 0:
                    if (".ends" in elements[0]):
                        break
                    elif ("." in elements[0]) or ("*" in elements[0]):
                        continue
                    else:
                        self._parse_line(elements)
        return self.component_list

    def _parse_line(self, line_elements: list):
        """ Parses a line from the netlist, already split into individual 
        elements, and converts it into a new ComponentModel object.

        Reads the elements on a line of the netlist (already delimited before 
        passed to _parse_line) and creates the appropriate object. Appends the 
        newly created object to the Parser's component_list.
        
        Parameters
        ----------
        line_elements : list
            A list of all the elements on a line (already split by some 
            delimiter).
        """

        # TODO: Consider having each component parse its own line, rather than
        # needing to add more case statements if new parameters show up.
        component = None
        nets = []
        pos = [0, 0]
        for item in line_elements[1:]:
            if "N$" in item:
                net = int(str(item).replace("N$", ''))
                nets.append(net)
            elif component is None:
                component = create_component_by_name(item)
            elif "lay_x=" in item:
                pos[0] = float(str(item).replace("lay_x=", ''))
            elif "lay_y=" in item:
                pos[1] = float(str(item).replace("lay_y=", ''))
            elif "wg_length=" in item:
                lenth = str(item).replace("wg_length=", '')
                component.extras['length'] = strToSci(lenth)
            elif "wg_width=" in item:
                width = str(item).replace("wg_width=", '')
                # Width needs to be stored in microns (um)
                component.extras['width'] = strToSci(width)*1e6
        component.nets = nets
        if any(x < 0 for x in nets):
            self.external_list.append([component.model.component_type, pos, nets])
        self.component_list.append(component)

def strToSci(number) -> float:
    """
    Converts string representations of numbers written with abbreviated 
    prefixes into a float with the proper exponent (e.g. '3u' -> 3e-6).
    Parameters
    ----------
    number : str
        The number to be converted, represented as a string.
    
    Returns
    -------
    float
        The string converted to a float.
    """
    ex = number[-1]
    base = float(number[:-1])
    if(ex == 'm'):
        return base * 1e-3
    elif(ex == 'u'):
        return base * 1e-6
    elif(ex == 'n'):
        return base * 1e-9
    else:
        return float(number(base) + ex)

def create_component_by_name(name: str):
    comp = SiEPIC_Simphony.config.selected_models[name]
    return core.ComponentInstance(model=comp)


# class TestStrToSci(object):
#     def test_milli(self):
#         str1 = '3m'
#         num1 = 3e-3
#         assert num1 == netlist.strToSci(str1)
#         str2 = '4.7m'
#         num2 = 4.7e-3
#         assert num2 == netlist.strToSci(str2)
#         str3 = '0.5m'
#         num3 = 0.5e-3
#         assert num3 == netlist.strToSci(str3)
#         str4 = '-0.37m'
#         num4 = -0.37e-3
#         assert num4 == netlist.strToSci(str4)
#         str5 = '-14.3m'
#         num5 = -14.3e-3
#         assert num5 == netlist.strToSci(str5)

#     def test_micro(self):
#         str1 = '3u'
#         num1 = 3e-6
#         assert num1 == netlist.strToSci(str1)
#         str2 = '4.7u'
#         num2 = 4.7e-6
#         assert num2 == netlist.strToSci(str2)
#         str3 = '0.5u'
#         num3 = 0.5e-6
#         assert num3 == netlist.strToSci(str3)
#         str4 = '-0.37u'
#         num4 = -0.37e-6
#         assert num4 == netlist.strToSci(str4)
#         str5 = '-14.3u'
#         num5 = -14.3e-6
#         assert num5 == netlist.strToSci(str5)
    
#     def test_nano(self):
#         str1 = '3n'
#         num1 = 3e-9
#         assert num1 == pytest.approx(netlist.strToSci(str1))
#         str2 = '4.7n'
#         num2 = 4.7e-9
#         assert num2 == pytest.approx(netlist.strToSci(str2))
#         str3 = '0.5n'
#         num3 = 0.5e-9
#         assert num3 == pytest.approx(netlist.strToSci(str3))
#         str4 = '-0.37n'
#         num4 = -0.37e-9
#         assert num4 == pytest.approx(netlist.strToSci(str4))
#         str5 = '-14.3n'
#         num5 = -14.3e-9
#         assert num5 == pytest.approx(netlist.strToSci(str5))